/**
 * @file skyscattering.h
 * @brief 
 * @author Emmanuel RUFFIO (emmanuel.ruffio@gmail.com)
 * @date 2001-12-25
 * @copyright Copyright (c) 2001-2017 Dream Overflow. All rights reserved.
 * @details 
 */

#ifndef _O3D_SKYSCATTERING_H
#define _O3D_SKYSCATTERING_H

#include "o3d/engine/sky/skybase.h"
#include "o3d/engine/sky/scatteringmodelbase.h"
#include "o3d/engine/sky/cloudlayerbase.h"

#include "o3d/engine/vertexbuffer.h"
#include "o3d/engine/primitive/dome.h"

#include "o3d/engine/shader/shader.h"

namespace o3d {

class ScatteringModelBase;

/**
 * @brief Definition of a sky renderer based on a scattering model
 * @date 2008-05-06
 * @author Emmanuel RUFFIO (emmanuel.ruffio@gmail.com)
 * Definition of a sky renderer based on standard physical model.
 * The sky shape is a dome generated by the class Dome.
 */
class O3D_API SkyScattering : public SkyBase
{
public:

	O3D_DECLARE_DYNAMIC_CLASS_NO_COPY(SkyScattering)

	//! Default constructor
	explicit SkyScattering(BaseObject * _pParent);
	//! The destructor
	virtual ~SkyScattering();

	//! Called after the renderer configuration
	void init();
	//! Returns whether or not the renderer is initialized
	Bool isInit() const;

	//! Call when the sky must be drawn
	virtual void draw(const DrawInfo &drawInfo);

	//! Update of the sky
	virtual void update();

	//! Add an object
	void addObject(SkyObjectBase*);
	//! Remove an object
	void removeObject(SkyObjectBase*);
	//! Find an object
	Bool findObject(SkyObjectBase*) const;

	//! Add a cloud layer
	void addCloudLayer(CloudLayerBase*);
	//! Remove a cloud layer
	void removeCloudLayer(CloudLayerBase*);
	//! Find a cloud layer
	Bool findCloudLayer(CloudLayerBase*) const;

	//! Warns the renderer that the time must change
	virtual void setTime(Double);
	//! @brief Returns the current time of the virtual world
	//! This function returns the current time used to draw the sky. It's not
	//! necessarily the time you requested.
	virtual Double getTime();

	//-----------------------------------------------------------------------------------
	// Model options
	//-----------------------------------------------------------------------------------

	//! @brief Defines the radius of the planet (in km)
	//! This values is used to computed the size of the dome (default is 6400km).
	//! @exception InvalidOperation exception if the renderer is initialized
	void setPlanetRadius(Float _radius);
	//! @brief Returns the planet radius
	Float getPlanetRadius() const { return m_datas.planetRadius; }

	//! @brief Defines the thickness of the atmosphere (in km)
	//! Default value is 40km
	//! @exception InvalidOperation exception if the renderer is initialized
	void setAtmosphereThickness(Float _thickness);
	//! @brief Returns the atmosphere thickness
	Float getAtmosphereThickness() const { return m_datas.atmThickness; }

	//! @brief Defines the phase function of molecules
	//! This function allows you to modify the phase function by specifying the two
	//! coefficients A and B defined by:
	//! Phase(theta) = 3.0/(16.0*PI) * (A + B * theta)
	//! @param _coefs a vector containing the coefficients A and B (default 1.0 and 1.0)
	void setMoleculePhaseFunctionCoefficients(const Vector2f & _coefs);
	//! @brief Returns the coefficients of the molecule phase function 
	const Vector2f getMoleculePhaseFunctionCoefficients() const { return Vector2f(m_datas.rayleighPhaseFunctionCoef1, m_datas.rayleighPhaseFunctionCoef2); }

	//! @brief Defines the density evolution of molecules in the atmosphere
	//! This function allows you to modify the two coefficients A and B in the formula:
	//! rho(z) = A * exp(- H / B) where H is the altitude, A in (/m^3), B in (m)
	//! @param _coefs a vector containing the coefficient A and B
	//!        (default 2.545E25 /m^3 and 8400 m)
	void setMoleculeDensity(const Vector2f _coefs);
	//! @brief Returns the molecule density coefficients
	const Vector2f getMoleculeDensity() const { return Vector2f(m_datas.rayDensityAtGround, m_datas.rayDensityDecFactor); }

	//! @brief Defines some property of the gaz
	//! This function is used to specify the index and the coefficient called
	//! "king factor" of the gaz of the atmosphere
	void setAtmGazProperty(const Vector2f _coefs);
	//! @brief Returns the gaz properties
	const Vector2f getAtmGazProperty() const { return Vector2f(m_datas.rayAirIndex, m_datas.rayKingFactor); }

	//! @brief Defines the density evolution of particles in the atmosphere
	//! This function allows you to modify the two coefficients A and B in the formula:
	//! rho(z) = A * exp(- H / B) where H is the altitude, A in (/m^3), B in (m)
	//! @param _coefs a vector containing the coefficient A and B
	//!        (default 30000E6 /m^3 and 1200 m)
	void setParticuleDensity(const Vector2f _coefs);
	//! @brief Returns the particle density coefficients
	const Vector2f getParticuleDensity() const { return Vector2f(m_datas.mieDensityAtGround, m_datas.mieDensityDecFactor); }

	//! @brief Defines the particle cross section coefficient
	//! Since it is very complicated to have a good modeling of this coefficient, you
	//! can have entire control on this value.
	//! @param _coef the cross section (default 3E-15f m^2)
	void setParticuleCrossSection(Float _coef);
	//! @brief Returns the particle cross section coefficient
	Float getParticuleCrossSection() const { return m_datas.mieCrossSection; }

	//! @brief Defines the anisotropic coefficient of particles
	//! For the moment there can be only one type of particles. This function
	//! allows you to define what kind of scattering is produced by these particles.
	//! @param _aniso the anisotropic coefficient (default 0.7)
	void setAnisotropicCoefficient(Float _aniso);
	//! @brief Returns the anisotropic coefficient of particles
	Float getAnisotropicCoefficient() const { return m_datas.mieAniso; }

	//! @brief Defines the post operation coefficients
	//! This coefficient are used to transform physical luminance into rgb colors.
	//! Let be L the physical luminance of the color distribution (Lr, Lg, Lb),
	//! C=(Cr, Cg, Cb) the rgb colors, Bp a "physical brightness" and Bc
	//! the "rgb brightness".
	//! To transform physical datas into rgb colors, the following computations are done:
	//! 1) Compute L = 0.5(MAX(Lr, Lg, Lb) + MIN(Lr, Lg, Lb))
	//! 2) Compute Bp = A - C.exp(- B * L) (1)
	//! 3) Compute Bc, the rgb brightness of the physical distribution:
	//!    Bc = 1.0/3.0 * (Lr + Lg + Lb)
	//! 4) Compute C by:
	//!    C_i = L_i * Bp/Bc
	//! The idea is to compute the rgb colors which have the brightness given by the
	//! formula (1).
	//! @param _coefs a vector containing the coefficients A,B and C
	void setPostOperationCoefficients(const Vector3 & _coefs);
	//! @brief Returns the post operation coefficients
	const Vector3 getPostOperationCoefficients() const { return Vector3(m_datas.postCoefA, m_datas.postCoefB, m_datas.postCoefC); }

	//-----------------------------------------------------------------------------------
	// Model optimisation options
	//-----------------------------------------------------------------------------------

	//! @brief Defines the first step length used by numerical integration
	//! The size of the first integration step is exactly :
	//! s0 = MIN(rayDensityDecFactor, mieDensityDecFactor) / _stepIndex
	//! @param _stepIndex the step index (default 4)
	void setIntegrationStepIndex(UInt32 _stepIndex);
	//! @brief Returns the integration step index
	UInt32 getIntegrationStepIndex() const { return m_datas.stepIndex; }

	//! @brief Defines the integration factor
	//! The integration factor is a scalar >= 1.0 that specifies how the integration step
	//! must increase: s_{n+1} = s_n * _stepFactor
	//! @param _stepFactor the step factor (default 2.0)
	void setIntegrationStepFactor(Float _stepFactor);
	//! @brief Returns the integration step factor
	Float getIntegrationStepFactor() const { return m_datas.stepFactor; }

	//! @brief Enable/Disable color interpolation
	//! With this options, some vertices are not computed if the color of its neighbors
	//! doesn't change "a lot".
	void enableColorInterpolation(Bool _state);
	Bool isColorInterpolation() const { return m_datas.colorInterpolation; }

	//! @brief Defines the color threshold (optimization)
	//! This optimization uses the fact that color gradients are low on a given stack of
	//! the sky dome. Let be C(V_i) the color of the vertex 'i':
	//! If (distance(C(V_{i-1}) - C(V_{i+1})) <= _threshold) Then
	//!      C(V_i) = 0.5 * (C(V_{i-1}) + C(V_{i+1}))
	//! Infinite norm is used.
	//! @param _threshold the comparison color threshold (default 0.02)
	void setColorThreshold(Float _threshold);
	//! @brief Returns the color threshold
	Float getColorThreshold() const { return m_datas.colorThreshold; }

	//-----------------------------------------------------------------------------------
	// Engine options
	//-----------------------------------------------------------------------------------

	//! @brief Defines the dome precision used to generate the geometry
	//! The computation cost increases rapidly with the precision.
	//! @param _precision the dome precision (default 3 = 768 triangles)
    //! @exception E_InvalidOperation exception if the renderer is initialized
    //! @see Dome
	void setDomePrecision(UInt32 _precision);
	//! @brief Returns the dome precision used to compute the sky vertices
	UInt32 getDomePrecision() const { return m_skyDome.getSubDiv(); }

	//! @brief Enable color forecasting
	//! With this option, the sky color is only computed each "timeStep". The colors
	//! are then interpolated each frames to provide a smooth transition.
    //! @see setTimeStep
	void enableForecast(Bool _value);
	//! @brief Returns whether or not the forecasting is activated
	Bool isForecast() const { return m_useForecast; }

	//! @brief Defines the time step
	//! This value is used if forecasting is activated. For example, if you request
	//! a time "t" by the function SetTime, the renderer will compute (t, t+timeStep,
	//! t+2*timeStep). It allows real time rendering even if the scattering model is
	//! CPU consumption.
	void setTimeStep(Double _value);
	//! @brief Returns the time step
	Double getTimeStep() const { return m_timeStep; }

	//! @brief Enable/Disable asynchronous computation
	void enableAsync(Bool _value);
	Bool isAsync() const { return m_useAsynch; }

	//-----------------------------------------------------------------------------------
	// Serialization
	//-----------------------------------------------------------------------------------

    virtual Bool writeToFile(OutStream & os);
    virtual Bool readFromFile(InStream & is);

	//-----------------------------------------------------------------------------------
	// Debugging
	//-----------------------------------------------------------------------------------

	//! @brief Returns the requested time
	//! It returns the time specify by the function SetTime.
	Double getRequestedTime() const { return m_requestTime; }

	//! @brief Returns the time bounds
	Vector3 getComputedTimeBounds() const;

	//! @brief Returns the current time bounds
	Vector2f getCurrentTimeBounds() const;

private:

	//-----------------------------------------------------------------------------------
	// Events
	//-----------------------------------------------------------------------------------

    void onTaskFinish(ScatteringModelBase::TaskData const &);

	//-----------------------------------------------------------------------------------
	// Internal
	//-----------------------------------------------------------------------------------

	void computeTime(Double, Bool);
	void keepTaskDatas(Int32, Bool _fromBack = True);
	void removeRemovedObject(ScatteringModelBase::T_ObjectArray & );

	//-----------------------------------------------------------------------------------
	// Types
	//-----------------------------------------------------------------------------------
	typedef std::vector<SmartObject<SkyObjectBase> >	T_SkyObjectArray;
	typedef T_SkyObjectArray::iterator					IT_SkyObjectArray;
	typedef T_SkyObjectArray::const_iterator			CIT_SkyObjectArray;

	typedef std::vector<SmartObject<CloudLayerBase> >	T_CloudLayerArray;
	typedef T_CloudLayerArray::iterator					IT_CloudLayerArray;
	typedef T_CloudLayerArray::const_iterator			CIT_CloudLayerArray;

	typedef std::list<ScatteringModelBase::TaskData>	T_VertexDataList;
	typedef T_VertexDataList::iterator					IT_VertexDataList;
	typedef T_VertexDataList::const_iterator			CIT_VertexDataList;

	//! @brief Structure containing some data used to draw the sky
	struct T_SkyDatas
	{
		//! Default constructor
        T_SkyDatas(Context *context);

		//! @brief Returns whether or not the data is defined
		Bool isValid() const { return vertexColorBuffer.exists(); }

		// members //
		ArrayBufferf vertexColorBuffer;		//!< Color attrib buffer

		Double time;						//!< The time

		Bool changed;						//!< Whether the data must be updated or not

		ScatteringModelBase::T_ObjectArray skyObjectArray;	//!< Data of all sky objects
	};

	//-----------------------------------------------------------------------------------
	// Members
	//-----------------------------------------------------------------------------------
	Dome m_skyDome;							//!< Sky geometry

	ElementArrayBufferui m_indexBuffer;		//!< Index buffer of the dome.
	ArrayBufferf m_vertexBuffer;		//!< Vertex buffer of the dome.

	T_SkyDatas m_currentData;				//!< The current or the last data
	T_SkyDatas m_forecastData;				//!< The forecast data

	T_SkyObjectArray m_objectArray;			//!< List of objects
	Bool m_objectArrayChanged;

	T_CloudLayerArray m_cloudArray;			//!< List of cloud layers

    Double m_currentTime;				    //!< The time
    Double m_requestTime;				    //!< The time requested for the next update

	T_VertexDataList m_taskDatasList;		//!< List of data
	T_VertexDataList m_taskDatasGarbage;

	ScatteringModelBase::TaskData m_datas;	//!< Data associated to a specific time
	ScatteringModelBase * m_pTask;

    ShaderInstance m_shader1;	//!< Shader used to render the sky
    ShaderInstance m_shader2;	//!< Shader used to render the sky

	Bool m_useForecast;			//!< Whether or not forecasting is activated
	Double m_timeStep;			//!< Step used to precompute data

	Bool m_useAsynch;			//!< Whether or not asynchronous computation is activated
};

} // namespace o3d

#endif // _O3D_SKYSCATTERING_H

